
# coding: utf-8

# In[106]:

get_ipython().run_cell_magic(u'', u'', u'%% Author: Levon Demirdjian\n%% Last Updated: 02/12/2018\n%% Description: This script implements \n%% an LSTM to forecast illness severity\n%% using time series of influenza \n%% prevalence in a number of regions \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_pdf import PdfPages\nimport numpy as np\nimport pandas as pd\nimport random\nimport tensorflow as tf\nfrom tensorflow.contrib.layers import fully_connected\n%matplotlib inline\n\n## Create tensorflow graph\ntf.reset_default_graph()    ## This would reset the graphs if there were already some running\n\n## Read data\ndata = pd.read_csv(\'region1_data.txt\', sep=" ")\nts   = data[[\'illness_signal\']]\n\n# Convert data into array that can be broken up into training batches\nTS = np.array(ts)\nn_steps   = 20\nf_horizon = 20\n\nx_data = TS[:(len(TS) - n_steps) - (len(TS) % n_steps)] ## So we can divide evenly into minibatches\ny_data = TS[f_horizon:(len(TS) - n_steps) - (len(TS) % n_steps) + f_horizon]\n\nx_batches = x_data.reshape(-1, n_steps, 1)\ny_batches = y_data.reshape(-1, n_steps, 1)\n\n## Testing data\ndef test_data(series, forecast, n_steps):\n    test_x_setup = TS[-(n_steps + forecast):]\n    testX = test_x_setup[:n_steps].reshape(-1, n_steps, 1)\n    testY = TS[-(n_steps):].reshape(-1, n_steps, 1)\n    return testX, testY\n\nX_test, Y_test = test_data(TS, f_horizon, n_steps)\n\n## Define graph\nn_inputs  = 1\nn_neurons = 100\nn_outputs = 1\n\n## Input and output placeholders\nX = tf.placeholder(tf.float32, [None, n_steps, n_inputs])\ny = tf.placeholder(tf.float32, [None, n_steps, n_outputs])\ndropout = tf.placeholder(tf.float32)\n\n#basic_cell = tf.contrib.rnn.BasicRNNCell(num_units = n_neurons, activation = tf.nn.relu) ## Create RNN object\n\n## Create RNN structure\n#basic_cell = tf.contrib.rnn.BasicRNNCell(num_units = n_neurons, activation = tf.nn.relu)\n#outputs, states = tf.nn.dynamic_rnn(basic_cell, X, dtype = tf.float32)  \n#multi_layer_cell = tf.contrib.rnn.MultiRNNCell([basic_cell] * n_layers)\n#outputs, states = tf.nn.dynamic_rnn(multi_layer_cell, X, dtype = tf.float32)\n\n## Create RNN structure\n#basic_cell = tf.contrib.rnn.BasicRNNCell(num_units = n_neurons, activation = tf.nn.relu)\nbasic_cell = tf.contrib.rnn.BasicLSTMCell(num_units = n_neurons, activation = tf.nn.tanh)\nrnn_outputs, states = tf.nn.dynamic_rnn(basic_cell, X, dtype = tf.float32)\nstacked_rnn_outputs = tf.reshape(rnn_outputs, [-1, n_neurons])\nstacked_outputs = fully_connected(stacked_rnn_outputs, n_outputs, activation_fn = None)\noutputs = tf.reshape(stacked_outputs, [-1, n_steps, n_outputs])\n\n## Define loss function and training algorithm\nlearning_rate = 0.01\nloss = tf.reduce_mean(tf.square(outputs - y))\noptimizer = tf.train.AdamOptimizer(learning_rate = learning_rate)\ntraining_op = optimizer.minimize(loss)\n\ninit = tf.global_variables_initializer()\n\n## Train the network\nn_iterations = 10000\nbatch_size = 20\n\nwith tf.Session() as sess:\n   init.run()\n   for iteration in range(n_iterations):\n       #X_batch, y_batch = [...]\n       sess.run(training_op, feed_dict = {X: x_batches, y: y_batches})\n       #sess.run(training_op, feed_dict = {X: X_batch, y: y_batch})\n       if iteration % 100 == 0:\n           mse      = loss.eval(feed_dict = {X: x_batches, y: y_batches})\n           mse_test = loss.eval(feed_dict = {X: X_test, y: Y_test})\n           print(iteration, "\\tMSE (train):", mse)\n           print(iteration, "\\tMSE (test):", mse_test)\n       \n       y_pred = sess.run(outputs, feed_dict = {X: X_test})\n\n\n## Plot results\ny_pred_series = pd.Series(np.ravel(y_pred))\nprint(y_pred_series)\n\nf = plt.figure()\nplt.title("Predicted illness signal in region 2", fontsize=14)\nplt.plot(pd.Series(np.ravel(Y_test)), label = "Actual")\nplt.plot(y_pred_series, label = "Forecast")\nplt.xlabel("Days into the future")\nplt.ylabel("Illness signal")\nplt.xticks(np.arange(0, 20, 1.0), np.arange(1, 21, 1))\nlegend = plt.legend(loc=\'upper left\', shadow=True)\nplt.show()\n\nf.savefig("foo.pdf", bbox_inches=\'tight\')')


# In[ ]:




# In[ ]:



